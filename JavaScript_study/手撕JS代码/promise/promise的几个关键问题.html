<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //1、如何改变promise的状态？
        // （1）resolve(value)：如果当前是pending就会变成resolved
        // （2）reject(reason)：如果当前是pending就会变成rejected
        // （3）抛出异常：如果当前是pending就会变成rejected
        //  注意，一旦promise的状态被改变，便不能再次改变（只能改一次）

        // 2、 一个promise指定多个成功 / 失败回调函数， 都会调用吗？
        // 当promise改变为对应状态时都会调用
        const p = new Promise((resolve, rejected) => {
            throw new Error('出错了')
        })
        p.then(
            value => {},
            reason => {
                console.log('reason', reason)
            }
        )
        p.then(
            value => {},
            reason => {
                console.log('reason', reason)
            }
        )

        // 3、改变promise状态和指定回调函数谁先谁后？
        // （1）都有可能，正常情况下是先指定回调再改变状态，但也可以先改状态再指定时间
        // （2）如何先改状态再指定回调？
        //    ①在执行器中直接调用resolve()/reject()
        //    ②延迟更长时间才调用then()
        // （3）什么时候才能得到数据？
        //    ①如果先指定的回调，那当状态发生改变时，回调函数就会调用，得到数据
        //    ②如果先改变的状态，那当指定回调时，回调函数就会调用，得到数据

        new Promise((resolve, rejiec) => {
            setTimeout(() => {
                resolve(1) // 后改变的状态（同时指定数据），异步执行回调函数
            }, 1000);
        }).then( // 先指定回调函数，保存当前指定的回调函数
            value => {},
            reason => {
                console.log(reason)
            }
        )

        new Promise((resolve, rejiec) => {
            resolve(1) // 先改变的状态（同时指定数据）
        }).then( // 指定回调函数，异步执行回调函数
            value => { // 里面的回调函数是异步执行的
                console.log(value);
            },
            reason => {
                console.log(reason)
            }
        )
        console.log("-----")

        // 4、promise.then()返回的新promise的结果状态由什么决定？
        // （1）简单表达：由then()指定的回调函数执行的结果决定
        // （2）详细表达：
        //      ①如果抛出异常，新promise变回rejected，reason为抛出的异常
        //      ②如果返回的是非promise的任意值，新promise变为resolved，value为返回的值
        //      ③如果返回的是另一个新promise，此promise的结果就会变成新promise的结果

        new Promise((resolve, reject) => {
            resolve(1)
                // reject(1)
        }).then(
            value => {
                console.log('onResolved1()', value) // onResolved1() 1
                    // return 1  // 返回了值，新promise的结果的value不再是undefined，而是返回的这个值
                    // return Promise.resolve(2)  // 返回了promise对象，新promise的结果就就是这个promise
                    // return Promise.reject(4)
                throw 5 // 抛出异常，新promise变为rejected，reason就是抛出的异常
            },
            reason => {
                console.log('onRejected1()', reason)
            }
        ).then(
            value => {
                console.log('onResolved2', value) // onResolved2 undefined
            },
            reason => {
                console.log('onRejected2', reason)
            }
        )

        // 5、promise如何串联多个操作任务？
        // (1) promise的then()返回一个新的promise，可以开成then()的链式调用
        // (2) 通过then的链式调用串联多个同步/异步任务

        new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log("执行任务一（异步）");
                resolve(1)
            }, 1000);
        }).then(
            value => {
                console.log('任务一的结果：', value);
                console.log("执行任务二（同步）");
                return 2
            }
        ).then(
            value => {
                console.log('任务二的结果', value);
                return new Promise((resolve, reject) => {
                    // 启动任务三（异步）
                    setTimeout(() => {
                        console.log('执行任务三（异步）');
                        resolve(3)
                    }, 1000);
                })
            }
        ).then(
            value => {
                console.log('任务三的结果', value);
                console.log('执行任务四');
                // resolve(4)
            }
        )



        // 6、promise异常传递/穿透？
        // （1）当使用promise的then链式调用时，可以在最后指定失败的回调
        //  (2) 前面任何操作出了异常，都会传到最后失败的回调中处理
        // 7、中断promise链？
        // （1）当使用promise的then链式调用时，在中间间断，不再调用后面的回调函数
        // （2）办法：在回调函数中返回一个pending状态的promise对象  return new Promise (()=> {})
        new Promise((resolve, reject) => {
            // resolve(1)
            reject(1)
        }).then(
            value => {
                console.log('onResolved1', value);
                return 2
            },
            reason => {
                throw reason // 默认可以不写
            }
        ).then(
            value => {
                console.log('onResolved2', value);
                return 3
            },
            reason => {
                throw reason
            }
        ).then(
            value => {
                console.log('onResolved3', value);
            },
            reason => Promise.reject(reason)

        ).catch(reason => {
            console.log('onRejected1', reason);
        })
    </script>
</body>

</html>