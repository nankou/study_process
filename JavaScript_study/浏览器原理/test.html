<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    // test this
    // var number = 5;
    // var obj = {
    //     number: 3,
    //     fn: (function() {
    //         var number;
    //         this.number *= 2;
    //         number = number * 2;
    //         number = 3;
    //         return function() {
    //             var num = this.number;
    //             this.number *= 2;
    //             console.log(num); // 10  6 
    //             number *= 3;
    //             console.log(number); //9  27
    //         }
    //     })()
    // }
    // var myFun = obj.fn;
    // myFun.call(null); // 全局this = 20 , number = 9
    // obj.fn(); // 
    // console.log(window.number); //20


    // function fn() {
    //     let name = '1'
    //     console.log(this.name);
    // }
    // var fn1 = {
    //     name: '3',
    //     fn: fn
    // }
    // var name = '2'
    // fn() // 2 指向全局
    // fn1.fn() //3 指向调用的对象
    //     // 需要注意的是：对象属性链中只有最后一层会影响到调用位置。
    // var fn2 = {
    //     name: 'fn2',
    //     fn1: fn1
    // }
    // fn2.fn1.fn() // 3 只有最后一层，也就是离它最近的那个对象

    // var length = 10;

    // function fn() {
    //     console.log(this.length);
    // }

    // var obj = {
    //     length: 5,
    //     method: function(fn) {
    //         fn();
    //         arguments[0](); // 调用了 fn()
    //     }
    // };

    // obj.method(fn, 1, 2, 4);

    // 总结： arguments 是一种特殊的对象。
    // 在函数中，我们无需指出参数名，就能访问。
    // 可以认为它是一种，隐式的传参形式。


    // async function foo() {
    //     console.log(1)
    //     let a = await 100
    //     console.log(a)
    //     console.log(2)
    // }
    // console.log(0)
    // foo()
    // console.log(3)


    // async function foo() {
    //     console.log('foo')
    // }
    // async function bar() {
    //     console.log('bar start')
    //     await foo()
    //     console.log('bar end')
    // }
    // console.log('script start')
    // setTimeout(function() {
    //         console.log(' setTimeout')
    //     }, 0) //宏队列异步
    // bar();
    // new Promise(function(resolve) {
    //     console.log('promise executor')
    //     resolve();
    // }).then(function() {
    //     console.log('promise then') //微队列异步
    // })
    // console.log('script end')
    //     //script start
    //     //bar start
    //     // foo
    //     // promise executor
    //     // script end

    // //bar end
    // //promise then
    // // setTimeout

    //     获取 url 中的参数
    // 1. 指定参数名称，返回该参数的值 或者 空字符串
    // 2. 不指定参数名称，返回全部的参数对象 或者 {}
    // 3. 如果存在多个同名参数，则返回数组

    // function getUrlParam(sUrl, sKey) {
    //     var keyString = sUrl.split("?")[1].split("#")[0].split("&") // 切割字符串
    //     var urlObj = new Object(); // 声明对象
    //     const urlArr = [] // 声明数组
    //     const valueArr = []
    //     if (sKey) {
    //         // 1. 指定参数名称，返回该参数的值 或者 空字符串
    //         keyString.forEach(element => {
    //             urlArr.push({
    //                 key: element.split('=')[0],
    //                 value: element.split('=')[1]
    //             })
    //         });
    //         urlArr.forEach(ntem => {
    //             if (ntem.key === sKey) {
    //                 valueArr.push(
    //                     ntem.value
    //                 )
    //             } else {
    //                 return ""
    //             }
    //         })
    //         if (valueArr.length === 1) {
    //             return valueArr[0] // 返回参数的值
    //         } else if (valueArr.length == 0) {
    //             return "" // 返回空字符串
    //         } else {
    //             return valueArr // 返回参数的数组
    //         }
    //     } else {
    //         if (keyString === undefined) {
    //             return {}
    //         } else {
    //             // 不指定参数名称，返回全部的参数对象 或者 {}
    //             keyString.forEach((ntem, index) => {
    //                 var tmp = ntem.split('=');
    //                 if (!(tmp[0] in urlObj)) {
    //                     urlObj[tmp[0]] = [];
    //                 }
    //                 urlObj[tmp[0]].push(tmp[1]);
    //             })
    //             return urlObj
    //         }

    //     }

    // }


    // var a = getUrlParam('http://www.nowcoder.com?key=1&key=2&key=3&key=4&test=4#hehe', 'abc');
    // console.log(a);
    // if (a === '') {
    //     console.log(true);
    // } else {
    //     console.log(false);
    // }

    // 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
    // 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
    // NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
    // function minNumberInRotateArray(rotateArray) {

    // }
    // let rotateArray = [3, 4, 5, 1, 2]
    // minNumberInRotateArray(rotateArray)


    // var ws = new WebSocket("wss://echo.websocket.org");

    // ws.onopen = function(evt) {
    //     console.log("Connection open ...");
    //     ws.send("Hello WebSockets!");
    // };

    // ws.onmessage = function(evt) {
    //     console.log("Received Message: " + evt.data);
    //     ws.close();
    // };

    // ws.onclose = function(evt) {
    //     console.log("Connection closed.");
    // };


    // function MoreThanHalfNum_Solution(numbers) {
    //     // write code here
    //     let times = numbers.length / 2;
    //     let obj = {};
    //     for (let i = 0; i < numbers.length; i++) {
    //         console.log(obj[numbers[i]]);
    //         if (!obj[numbers[i]]) {
    //             obj[numbers[i]] = 1;
    //         } else {
    //             obj[numbers[i]]++;
    //         }
    //         if (obj[numbers[i]] > times) {
    //             // return numbers[i]
    //             console.log(numbers[i]);
    //         }
    //     }
    //     // return 0
    //     console.log(0);
    // }

    // MoreThanHalfNum_Solution([1, 2, 3, 2, 2, 2, 5, 4, 2])

    // function FindGreatestSumOfSubArray(array) {
    //     // write code here
    //     let newArray = [];
    //     var result = 0
    //     for (let i = 0; i < array.length; i++) {
    //         if (array[i] > 0) {
    //             newArray.push(array[i])
    //         }
    //     }
    //     newArray.forEach(item => {
    //         result = result + item
    //     })
    //     console.log(result);
    // }

    // FindGreatestSumOfSubArray([1, -2, 3, 10, -4, 7, 2, -5])
    // var moveZeroes = function(nums) {
    //     let j = 0;
    //     for (let i = 0; i < nums.length; i++) {
    //         if (nums[j] === 0) {
    //             // 把0去掉
    //             nums.splice(j, 1)
    //                 // 在最末尾加一个0
    //             nums[nums.length] = 0
    //         } else {
    //             j++
    //         }

    //     }
    // };
    // let nums = [0, 1, 0, 3, 12];
    // moveZeroes(nums)
    // console.log(nums)

    // 快速排序
    function quickSort(arr, left, right) {
        /*
         * len为数组的长度;
         * left为需要数组中参与排序的起始点；right为数组中参与排序的终止点;
         * left如果有传数字那么就为left，没有传参则为0；
         * right如果有传参那么就为right，没有传参则为len-1;
         * 有传参可能会部分排序可能不会排序，没传参默认排序整个数组;
         * partitionIndex为分组界限;
         */
        var len = arr.length,
            partitionIndex,
            left = typeof left !== 'number' ? 0 : left,
            right = typeof right !== 'number' ? len - 1 : right;

        // 如果需要排序的起始索引小于终止索引则执行排序;递归的终止条件；
        if (left < right) {

            // partition的返回值作为partitionIndex来分隔数组；
            // 索引partitionIndex左边的元素均小于arr[partitionIndex]；
            // 右边的元素均大于arr[partitionIndex]；
            partitionIndex = partition(arr, left, right);

            // 数组中小于arr[partitionIndex]的部分(索引left到partitionIndex-1)再次使用quickSort排序；
            quickSort(arr, left, partitionIndex - 1);

            // 数组中大于arr[partitionIndex]的部分(索引partitionIndex+1到right)再次使用quickSort排序；
            quickSort(arr, partitionIndex + 1, right);
        }
        // 递归执行直到不满足left<right;返回本身；
        return arr;
    }

    // 分区排序
    function partition(arr, left, right) {
        /*
         * 这部分是具体实现排序的部分；
         * 将left赋值给pivot，作为参照物，因为left在最左边，只需要从左到右比较一遍即可判断整个数组；
         * index索引是arr中待交换位置；
         */
        var pivot = left,
            index = pivot + 1;
        // for循环从参照物arr[pivot]下一个元素arr[pivot+1]开始一直比较到子数组结束arr[right]；
        for (var i = index; i <= right; i++) {

            // 循环中如果有任何小于参照物的，就将他交换到index的位置，然后index向右移动到下一个位置；
            if (arr[i] < arr[pivot]) {
                swap(arr, i, index);
                index++;
            }
        }
        /*
         * 因为每次都是交换完后index移动到下一个位置，所以在循环结束时，index仍为待交换的位置；
         * 此时索引pivot+1到index-1的元素都小于参照物arr[pivot]；
         */

        // 交换pivot和index-1索引的值之后index-1索引左边全都是小于arr[index-1]的元素；
        swap(arr, pivot, index - 1);

        // 返回index-1作为拆分子数组的分界线；
        return index - 1;
    }
    /*
     * 普通的交换，将a[i]和a[j]的数值交换；
     */
    function swap(arr, i, j) {
        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    let test2 = [5, 3, 2, 1, 4, 4, 6];
    let res = quickSort(test2);

    console.log(res);
</script>